# baaz-inventory

Project Overview
This project is a lightweight inventory‑dashboard built with Next.js 14, TypeScript, and Tailwind CSS. It mimics the internal table that Baaz Bikes might use to inspect stock levels. All inventory data is pulled from a public dummy endpoint (https://dev.electorq.com/dummy/inventory). The heart of the application is a fully reusable <DataTable /> component: you pass it any data array plus a simple column definition, and it automatically supplies global search, column sorting, per‑column filtering, pagination controls, and a responsive layout that looks good from small phones to 4‑K desktops. Because the table is headless, you can drop it into other projects with almost no changes. A bonus branch demonstrates how the same UI can be wired to Redux Toolkit for larger state needs, but the main branch keeps state local with React hooks to stay lean.

Local Setup Instructions
To run the dashboard locally you only need Node 18 + and a package manager. Clone the repository, install the dependencies, and start the dev server (pnpm install && pnpm dev, or use npm / yarn if you prefer). The site opens at http://localhost:3000. No environment variables are required because the demo fetches straight from the public API, but you can point the app at your own backend by adding NEXT_PUBLIC_INVENTORY_API=<your‑url> to an .env.local file.

Features Implemented
Once the page loads you are greeted by a single search bar. Typing a component ID or name filters the dataset in real time; matching rows appear instantly in the five‑column table (parent component, sub‑component, available quantity, damaged quantity, total quantity). Each column header can be clicked to toggle ascending or descending sort, and a text filter under every header lets you narrow results for that specific field. Pagination is built in, with a size selector and first‑/previous‑/next‑/last buttons. The table handles horizontal overflow gracefully on small screens, keeps its header sticky on larger ones, and updates at 60 fps even on sizeable datasets thanks to memoised calculations. Code quality is kept high with strict TypeScript, ESLint, Prettier, and a Husky pre‑commit hook. The app is automatically deployed to Vercel, so every push to main gives you a live preview without extra configuration.
 
